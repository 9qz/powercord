/**
 * Powercord, a lightweight @discord client mod focused on simplicity and performance
 * Copyright (C) 2018-2020  aetheryx & Bowser65
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

const { CACHE_FOLDER } = require('powercord/constants');
const { readFileSync, writeFile, existsSync, mkdirSync } = require('fs');
const { createHash } = require('crypto');
const { join } = require('path');

// @todo: Schedule a cache cleanup?

/**
 * Main class for compilers used in Powercord.
 * @property {String} file File to compile
 * @property {String} cacheDir Path where cached files will go
 * @abstract
 */
class Compiler {
  constructor (file) {
    this.file = file;
    this.cacheDir = join(CACHE_FOLDER, this.constructor.name.toLowerCase());

    if (!existsSync(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }

  /**
   * Compiles the file (if necessary), and perform cache-related operations.
   * @returns {Promise<String>|String} Compilation result
   */
  compile () {
    // Attemt to fetch from cache
    const cacheKey = this.computeCacheKey();
    if (cacheKey instanceof Promise) {
      return cacheKey.then(this._doCompilation.bind(this));
    }
    return this._doCompilation(cacheKey);
  }

  /** @private */
  _doCompilation (cacheKey) {
    let cacheFile;
    if (cacheKey) {
      cacheFile = join(this.cacheDir, cacheKey);
      if (existsSync(cacheFile)) {
        const compiled = readFileSync(cacheFile, 'utf8');
        return compiled;
      }
    }

    // Perform compilation
    const compiled = this._compile();

    if (compiled instanceof Promise) {
      return compiled.then(finalCompiled => {
        if (cacheFile) {
          writeFile(cacheFile, finalCompiled, () => void 0);
        }
        return finalCompiled;
      });
    }
    if (cacheFile) {
      writeFile(cacheFile, compiled, () => void 0);
    }
    return compiled;
  }

  /**
   * Lists all files involved during the compilation (parent file + imported files)
   * Only applicable if files are concatenated during compilation (e.g. scss files)
   * @returns {Promise<String[]>|String[]}
   */
  listFiles () {
    return [ this.file ];
  }

  /**
   * Computes the hash corresponding to the file we're compiling.
   * MUST take into account imported files (if any) and always return the same hash for the same given file.
   * @returns {Promise<String|null>|String|null} Cache key, or null if cache isn't available
   */
  computeCacheKey () {
    const files = this.listFiles();
    if (files instanceof Promise) {
      return files.then(this._computeCacheKey.bind(this));
    }
    return this._computeCacheKey(files);
  }

  /** @private */
  _computeCacheKey (files) {
    const hashes = files.map(this.computeFileHash.bind(this));
    if (hashes.length === 1) {
      return hashes[0];
    }
    const hash = createHash('sha1');
    hashes.forEach(h => hash.update(h));
    return hash.digest('hex');
  }

  /**
   * Computes the hash of a given file
   * @param {String} file File path
   */
  computeFileHash (file) {
    if (!existsSync(file)) {
      throw new Error('File doesn\'t exist!');
    }

    const fileBuffer = readFileSync(file);
    return createHash('sha1')
      .update(this._metadata)
      .update(fileBuffer)
      .digest('hex');
  }

  /**
   * Compiles the file. Should NOT perform any cache-related actions
   * @returns {Promise<String>} Compilation results.
   */
  _compile () {
    throw new Error('Not implemented');
  }

  /**
   * @returns {String} Compiler metadata (compiler used, version)
   */
  get _metadata () {
    return '';
  }
}

module.exports = Compiler;
