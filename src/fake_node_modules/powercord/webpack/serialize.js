/**
 * Copyright (c) 2018-2020 aetheryx & Bowser65
 * All Rights Reserved. Licensed under the Porkord License
 * https://powercord.dev/porkord-license
 */

/* global FinalizationRegistry */

const PTR_MARKER = Symbol('powercord.serialize.pointer-marker');
const isMainWorld = typeof require === 'undefined';
let _commandHandler = () => void 0;

// --
// Memory management
// MAIN WORLD SIDE
// --
let ptr = 0;
const memorySpace = {};
const pointerMap = new WeakMap();
function allocatePointer (obj) {
  if (!pointerMap.has(obj)) {
    memorySpace[ptr] = obj;
    pointerMap.set(obj, ptr++);
  }

  return pointerMap.get(obj);
}

// eslint-disable-next-line no-unused-vars
function freePointer (ptr) {
  pointerMap.delete(memorySpace[ptr]);
  delete memorySpace[ptr];
}

function readPointer (ptr) {
  return memorySpace[ptr];
}


// --
// Memory management
// RENDERER WORLD SIDE
// --
const usedPointers = {};
const localPointerProperties = {};
const registry = isMainWorld
  ? null
  : new FinalizationRegistry((ptr) => {
    usedPointers[ptr]--;
    if (usedPointers[ptr] === 0) {
      if (ptr in localPointerProperties) {
        delete localPointerProperties[ptr];
      }

      _commandHandler('releasePointer', ptr);
    }
  });

function usePointer (descriptor, ptr) {
  ptr = ptr ?? descriptor.ptr;
  usedPointers[ptr] = (usedPointers[ptr] || 0) + 1;
  registry.register(descriptor, ptr);
}


// --
// Real job
// --
let classRefId = 0;
const classMap = new WeakMap();
let htmlSerialId = isMainWorld ? 0 : 1;
function serialize (obj, seen = new WeakMap()) {
  if (obj === null || obj === void 0) {
    return obj;
  }

  if ([ 'boolean', 'string', 'number', 'bigint', 'undefined' ].includes(typeof obj) || obj instanceof Date) {
    return obj;
  }

  if (obj instanceof Promise) {
    return obj.then((v) => serialize(v));
  }

  if (obj === window) {
    return { $$type: '$window' };
  }

  if (obj === document) {
    return { $$type: '$document' };
  }

  if (obj instanceof Element) {
    obj.dataset.powercordSerializeId = htmlSerialId;
    const ptr = htmlSerialId;
    htmlSerialId += 2;
    return {
      $$type: '$html',
      ptr
    };
  }

  if (typeof obj === 'symbol') {
    return {
      $$type: '$symbol',
      value: Symbol.keyFor(obj)
    };
  }

  if (isMainWorld) {
    const ptr = allocatePointer(obj);
    if (Array.isArray(obj)) {
      return {
        $$type: '$array',
        data: obj.map((v) => serialize(v, seen)),
        ptr
      };
    }

    const type = typeof obj === 'function'
      ? obj.prototype && Object.keys(obj.prototype).length ? 'class' : 'function'
      : 'object';

    return {
      $$type: '$pointer',
      ptr,
      type
    };
  }

  if ('__$$pointer' in obj) {
    if (obj.__$$pointerType === 'class' && !obj.prototype.constructor.__$$props) {
      const serializedProto = {};
      for (const mth of Reflect.ownKeys(obj.prototype)) {
        if ([ 'constructor', '__$$remotePrototype' ].includes(mth)) {
          continue;
        }

        serializedProto[mth] = serialize(obj.prototype[mth]);
      }

      function construct (args, ptr) {
        obj.prototype.__$$ptr = ptr;
        obj.prototype.__$$marker = PTR_MARKER;
        // eslint-disable-next-line new-cap, no-use-before-define
        const instance = new obj(...deserialize(args));
        usePointer(instance, ptr);
        return serialize(instance);
      }

      const ref = classMap.get(obj) ?? classRefId++;
      classMap.set(obj, ref);
      return {
        $$type: '$pointer',
        type: 'class',
        ptr: obj.__$$pointer,
        props: serializedProto,
        construct,
        ref
      };
    }

    return {
      $$type: '$pointer',
      ptr: obj.__$$pointer
    };
  }

  if (seen.has(obj)) {
    return seen.get(obj);
  }

  if (Array.isArray(obj)) {
    const res = [];
    seen.set(obj, res);
    for (const v of obj) {
      res.push(serialize(v, seen));
    }

    return res;
  }

  if (typeof obj === 'function') {
    const wrapper = (...args) => {
      // eslint-disable-next-line no-use-before-define
      const preparedArgs = deserialize(args);
      const res = obj.call(...preparedArgs);
      return serialize(res);
    };

    seen.set(obj, wrapper);
    return wrapper;
  }

  if (obj instanceof Set) {
    const res = new Set();
    seen.set(obj, res);
    for (const item of obj) {
      res.add(serialize(item, seen));
    }

    return res;
  }

  if (obj instanceof Map) {
    const res = new Map();
    seen.set(obj, res);
    for (const k in obj) {
      if (k in obj) {
        res.set(k, serialize(res[k], seen));
      }
    }

    return res;
  }

  const res = {};
  seen.set(obj, res);
  for (const k in obj) {
    if (k in obj) {
      res[k] = serialize(obj[k], seen);
    }
  }

  return res;
}

const pointerProxyHandler = {
  get: (target, key) => {
    const props = target.__$$props || target;
    if (key === '__$$pointer') {
      return props.ptr;
    }

    if (key === '__$$pointerType') {
      return props.type;
    }

    if (key === 'prototype') {
      if (target.prototype) {
        // todo: make better & get rid of special case in injector?
        const remote = _commandHandler('getObjectProperty', props.ptr, 'prototype');
        // eslint-disable-next-line no-use-before-define
        target.prototype.__$$remotePrototype = deserialize(remote);
      }

      return target.prototype;
    }

    if (key === 'remotePrototype') {
      key = 'prototype';
    }

    if (typeof target === 'function' && [ 'bind', 'call', 'apply' ].includes(key)) {
      return target[key];
    }

    if (props.ptr in localPointerProperties && key in localPointerProperties[props.ptr]) {
      return localPointerProperties[props.ptr][key];
    }

    const res = _commandHandler('getObjectProperty', props.ptr, key);
    // eslint-disable-next-line no-use-before-define
    return deserialize(res);
  },
  set: (target, key, value) => {
    const props = target.__$$props || target;
    if (!localPointerProperties[props.ptr]) {
      localPointerProperties[props.ptr] = {};
    }

    if (value && typeof value === 'object' && !('__$$pointer' in value)) {
      // Cache local objects to avoid unnecessary IPC roundtrips.
      localPointerProperties[props.ptr][key] = value;
    }

    _commandHandler('setObjectProperty', props.ptr, key, serialize(value));
    return true;
  },
  deleteProperty: (target, key) => {
    const props = target.__$$props || target;
    _commandHandler('deleteObjectProperty', props.ptr, key);
    return true;
  },
  has: (target, key) => {
    if ([ '__$$pointer', '__$$pointerType' ].includes(key)) {
      return true;
    }

    const props = target.__$$props || target;
    return _commandHandler('hasObjectKey', props.ptr, key);
  },
  ownKeys: (target) => {
    const props = target.__$$props || target;
    const targetKeys = Reflect.ownKeys(target);
    const remoteKeys = _commandHandler('getObjectOwnKeys', props.ptr);
    return Array.from(new Set([].concat(targetKeys, remoteKeys)));
  },
  getOwnPropertyDescriptor: (target, key) => {
    const props = target.__$$props || target;
    const targetDesc = Object.getOwnPropertyDescriptor(target, key);
    if (targetDesc && !targetDesc.configurable) {
      return targetDesc;
    }

    // eslint-disable-next-line no-use-before-define
    const desc = _commandHandler('getObjectPropertyDescriptor', props.ptr, key);
    if (!desc) {
      return void 0;
    }

    const res = {
      configurable: true,
      enumerable: desc.enumerable
    };

    if ('value' in desc) {
      res.writable = desc.writable;
      // eslint-disable-next-line no-use-before-define
      res.value = deserialize(desc.value);
    }

    if ('get' in desc) {
      // eslint-disable-next-line no-use-before-define
      res.get = deserialize(desc.get);
    }

    if ('set' in desc) {
      // eslint-disable-next-line no-use-before-define
      res.set = deserialize(desc.set);
    }

    return res;
  },
  getPrototypeOf: (target) => {
    const props = target.__$$props || target;
    const res = _commandHandler('getObjectProperty', props.ptr, '__proto__');
    // eslint-disable-next-line no-use-before-define
    return deserialize(res);
  },
  apply: (target, thisArg, args) => {
    const props = target.__$$props || target;
    if (props.type === 'class') {
      // eslint-disable-next-line new-cap
      return new target(...args);
    }

    return target.call(thisArg, ...args);
  }
};

const classProxyHandler = {
  get: (target, key) => {
    if (key in target) {
      return target[key];
    }

    if (key === '__$$pointer') {
      return target.__$$remotePtr;
    }

    if (key === '__$$pointerType') {
      return 'object';
    }

    const res = _commandHandler('getObjectProperty', target.__$$remotePtr, key);
    // eslint-disable-next-line no-use-before-define
    return deserialize(res);
  },
  set: (target, key, value) => {
    if (key in target || key.startsWith('__$$')) {
      target[key] = value;
    }

    if (![ '__$$remotePtr' ].includes(key)) {
      _commandHandler('setObjectProperty', target.__$$remotePtr, key, serialize(value));
    }

    return true;
  },
  deleteProperty: (target, key) => {
    _commandHandler('deleteObjectProperty', target.__$$remotePtr, key);
    return true;
  },
  has: (target, key) => {
    if ([ '__$$pointer', '__$$pointerType' ].includes(key)) {
      return true;
    }

    return _commandHandler('hasObjectKey', target.__$$remotePtr, key);
  },
  ownKeys: (target) => _commandHandler('getObjectOwnKeys', target.__$$remotePtr),
  getOwnPropertyDescriptor: (target, key) => {
    const desc = _commandHandler('getObjectPropertyDescriptor', target.__$$remotePtr, key);
    return {
      configurable: true,
      ...desc
    };
  }
};

const arrayProxyHandler = {
  get: (target, key) => {
    if ([ 'pop', 'shift', 'push', 'unshift' ].includes(key)) {
      return (...args) => {
        _commandHandler('performArrayOperation', key, target.__$$pointer, serialize(args));
        return target[key](...args);
      };
    }

    return target[key];
  },
  set: (target, key, value) => {
    _commandHandler('performArrayOperation', 'set', target.__$$pointer, [ key, serialize(value) ]);
    target[key] = value;
    return true;
  }
};

const mainWorldClassMap = {};
function deserialize (obj, seen = new WeakMap()) {
  if (obj === null || obj === void 0) {
    return obj;
  }

  if ([ 'boolean', 'string', 'number', 'bigint', 'undefined' ].includes(typeof obj) || obj instanceof Date) {
    return obj;
  }

  if (obj instanceof Promise) {
    return obj.then((v) => deserialize(v));
  }

  if (obj.$$type === '$pointer') {
    if (isMainWorld) {
      const res = readPointer(obj.ptr);
      if (obj.type === 'class') {
        if (!mainWorldClassMap[obj.ref]) {
          class Klass extends res {
            constructor (...args) {
              super(...args);
              const ptr = allocatePointer(this);
              const res = obj.construct(serialize(args), ptr);
              Object.assign(this, deserialize(res));
            }
          }

          for (const mth in obj.props) {
            if (mth in obj.props) {
              Klass.prototype[mth] = deserialize(obj.props[mth]);
            }
          }

          mainWorldClassMap[obj.ref] = Klass;
        }

        return mainWorldClassMap[obj.ref];
      }

      return res;
    }

    usePointer(obj);
    if (obj.type === 'function') {
      const props = obj;
      obj = function (...args) {
        const thisArg = serialize(this);
        const preparedArgs = serialize(args);
        const res = _commandHandler('invokeFunction', props.ptr, thisArg, preparedArgs);
        return deserialize(res);
      };

      obj.__$$props = props;
    }

    if (obj.type === 'class') {
      const props = obj;
      obj = class {
        constructor (...args) {
          if (this.__$$marker === PTR_MARKER) {
            // eslint-disable-next-line prefer-destructuring
            this.__$$remotePtr = this.__$$ptr;
            delete this.__$$marker;
            delete this.__$$ptr;
          } else {
            const preparedArgs = serialize(args);
            const res = _commandHandler('instantiateClass', props.ptr, preparedArgs);
            this.__$$remotePtr = res.ptr;
          }

          const proxy = new Proxy(this, classProxyHandler);
          let proto = Object.getPrototypeOf(this);
          while (proto) {
            for (const key of Reflect.ownKeys(proto)) {
              if ([ 'constructor', '__$$remotePrototype', '__$$remotePtr' ].includes(key)) {
                continue;
              }

              proxy[key] = this[key];
            }

            proto = Object.getPrototypeOf(proto);
          }

          return proxy;
        }
      };

      const prototype = deserialize(_commandHandler('getObjectProperty', props.ptr, 'prototype'));
      for (const mth of Reflect.ownKeys(prototype)) {
        if ([ 'constructor', '__$$remotePrototype' ].includes(mth)) {
          continue;
        }

        if (!(mth in prototype)) {
          continue;
        }

        const desc = Object.getOwnPropertyDescriptor(prototype, mth);
        if (typeof desc.value === 'function') {
          const { value } = desc;
          obj.prototype[mth] = function (...args) {
            const preparedArgs = serialize(args);
            const res = _commandHandler('invokeFunction', value.__$$pointer, serialize(this), preparedArgs);
            return deserialize(res);
          };
        } else if ('value' in desc) {
          obj.prototype[mth] = desc.value;
        } else {
          Object.defineProperty(obj.prototype, mth, desc);
        }
      }

      obj.__$$props = props;
      obj.__$$isRemote = true;
    }

    return new Proxy(obj, pointerProxyHandler);
  }

  if (obj.$$type === '$array') {
    usePointer(obj);
    const res = obj.data.map((v) => deserialize(v, seen));
    res.__$$pointer = obj.ptr;

    return new Proxy(res, arrayProxyHandler);
  }

  if (obj.$$type === '$window') {
    return window;
  }

  if (obj.$$type === '$document') {
    return document;
  }

  if (obj.$$type === '$html') {
    const element = document.querySelector(`[data-powercord-serialize-id="${obj.ptr}"]`);
    element.removeAttribute('data-powercord-serialize-id');
    return element;
  }

  if (obj.$$type === '$symbol') {
    return Symbol.for(obj.value);
  }

  if (typeof obj === 'function') {
    return function (...args) {
      const thisArg = serialize(this);
      const preparedArgs = args.map((arg) => serialize(arg));
      const res = obj(thisArg, ...preparedArgs);
      return deserialize(res);
    };
  }

  if (Array.isArray(obj)) {
    return obj.map((v) => deserialize(v, seen));
  }

  if (obj instanceof Set) {
    const res = new Set();
    for (const item of obj) {
      res.add(deserialize(item, seen));
    }

    return res;
  }

  if (obj instanceof Map) {
    const res = new Map();
    for (const k in obj) {
      if (k in obj) {
        res.set(k, deserialize(res[k], seen));
      }
    }

    return res;
  }

  if (seen.has(obj)) {
    return seen.get(obj);
  }

  const res = {};
  seen.set(obj, res);
  for (const k in obj) {
    if (k in obj) {
      res[k] = deserialize(obj[k], seen);
    }
  }

  return res;
}


// --
// Exports if in renderer
// --
if (!isMainWorld) {
  module.exports = {
    serialize,
    deserialize,
    setCommandHandler: (h) => (_commandHandler = h)
  };
}
